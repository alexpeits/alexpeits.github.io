<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-22T16:02:04+01:00</updated><id>http://localhost:4000/</id><title type="html">alexpeits</title><subtitle>Programmer, musician, software developer &lt;a href=&quot;https://www.sohonet.com&quot;&gt;@sohonet&lt;/a&gt;.</subtitle><entry><title type="html">An introduction to dependent types in Haskell</title><link href="http://localhost:4000/programming/2018/09/18/haskell-dependent-types-1.html" rel="alternate" type="text/html" title="An introduction to dependent types in Haskell" /><published>2018-09-18T00:00:00+01:00</published><updated>2018-09-18T00:00:00+01:00</updated><id>http://localhost:4000/programming/2018/09/18/haskell-dependent-types-1</id><content type="html" xml:base="http://localhost:4000/programming/2018/09/18/haskell-dependent-types-1.html">&lt;h2 id=&quot;use-cases&quot;&gt;Use cases&lt;/h2&gt;

&lt;p&gt;Even though there can be a lot of areas where using dependent types would prove beneficial, for
example building a type checker, the quintessential example is length-indexed vectors.  In more
simple words, lists that carry information about their length as a phantom parameter (more on that
later), and force the programmer to use this information to prove the correctness of operations such
as concatenating two vectors. Since this information exists at the type level, it means that the
usual signature for list concatenation:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;does not apply here. This is because, since we have the length of the vector in the actual vector type,
a vector would look like this: &lt;code class=&quot;highlighter-rouge&quot;&gt;Vec a n&lt;/code&gt; where &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; is the type of the elements the vector contains and
&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is the length of the vector (at the type level). So the signature for concatenation should look
something like:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;How the hell can we know what the length of the two vectors provided will be when we write the code?
Of course we could try and cheat the compiler by writing:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but it’s not that easy: since the vectors carry their length in the type, we somehow have to reason
as to what the length of the final vector will be. In this particular example, it is easy to deduce
that the final length should be the sum of the lengths of the two vectors provided, so &lt;code class=&quot;highlighter-rouge&quot;&gt;n + m&lt;/code&gt;. But
we still need to somehow tell that to the compiler.&lt;/p&gt;

&lt;h2 id=&quot;natural-numbers&quot;&gt;Natural numbers&lt;/h2&gt;

&lt;p&gt;The first step towards implementing our concatenation is somehow defining natural numbers at the
type level. The key to that is using Peano natural numbers and a language extension called DataKinds.&lt;/p&gt;

&lt;p&gt;Peano natural numbers is a recursive definition of positive natural numbers (so 0, 1, 2 …). To
achieve that, we define a base number, and say that the next number is its successor, then the next
one is the successor of the successor and so on. The base number will obviously be 0. Then 1 is
defined as the successor of 0, and 2 as the successor of 1, or the successor of the successor of 0.
To put that in a data type definition in Haskell:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What this definition tells us is that &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; is a natural number, and then the constructor &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; with a
natural number as an argument is also a natural number. For example &lt;code class=&quot;highlighter-rouge&quot;&gt;S Z&lt;/code&gt; is a natural number, and
it turns out it represents 1, because it is the successor of 0. Similarly, &lt;code class=&quot;highlighter-rouge&quot;&gt;S (S Z)&lt;/code&gt; is 2.&lt;/p&gt;

&lt;p&gt;But at the value level these numbers are as useful as actual &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;s. What we need is to use them
to describe something at the type level, like the vectors in the previous section. The type of
a vector that contains &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;s and has length 3 would be &lt;code class=&quot;highlighter-rouge&quot;&gt;Vec String (S (S (S Z)))&lt;/code&gt;. This is
where &lt;code class=&quot;highlighter-rouge&quot;&gt;DataKinds&lt;/code&gt; comes to play.&lt;/p&gt;

&lt;p&gt;What &lt;code class=&quot;highlighter-rouge&quot;&gt;DataKinds&lt;/code&gt; does is promote our &lt;em&gt;value constructors&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;) to &lt;em&gt;type constructors&lt;/em&gt;, and
our &lt;em&gt;type constructors&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Nat&lt;/code&gt;) to &lt;em&gt;kinds&lt;/em&gt;. This means that along with what we get from the definition
above:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;we also get:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="haskell" /><category term="dependent types" /><summary type="html"></summary></entry><entry><title type="html">Formatting timesheet tables in org-mode</title><link href="http://localhost:4000/programming/2017/02/12/org-timesheets.html" rel="alternate" type="text/html" title="Formatting timesheet tables in org-mode" /><published>2017-02-12T00:00:00+00:00</published><updated>2017-02-12T00:00:00+00:00</updated><id>http://localhost:4000/programming/2017/02/12/org-timesheets</id><content type="html" xml:base="http://localhost:4000/programming/2017/02/12/org-timesheets.html">&lt;p class=&quot;note&quot;&gt;This post is originally adapted from &lt;a href=&quot;https://emacs.stackexchange.com/questions/23808/how-to-plot-summaries-of-timestamps-of-different-projects-clocking-in-and-out/23862#23862&quot;&gt;this&lt;/a&gt;
stackoverflow answer.&lt;/p&gt;

&lt;p&gt;Org-mode is a great productivity tool, and has a lot of functionality out of
the box, including utilities for tracking time spent on a task/project. For
example, by pressing &lt;code class=&quot;highlighter-rouge&quot;&gt;C-c C-x C-i&lt;/code&gt; on a heading, a timer is added (clock-in),
and by pressing &lt;code class=&quot;highlighter-rouge&quot;&gt;C-c C-x C-o&lt;/code&gt; the timer stops (clock-out). Org-mode also
supports adding a report with &lt;code class=&quot;highlighter-rouge&quot;&gt;org-clock-report&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;C-c C-x C-r&lt;/code&gt;), but, even
with the customization it offers, it is not ideal for having a fully custom
report and be able to export it to csv and whatnot.&lt;/p&gt;

&lt;p&gt;Fortunately, newer versions of org-mode come with a utility called
&lt;em&gt;org-element&lt;/em&gt;, which adds the ability to parse org-mode buffers as trees. This
proves really helpful to take all &lt;code class=&quot;highlighter-rouge&quot;&gt;clock&lt;/code&gt; elements from a buffer and put them
in a table.&lt;/p&gt;

&lt;p&gt;To do this, we use the following elisp code block in the respective buffer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot; data-lang=&quot;none&quot;&gt;#+BEGIN_SRC elisp
  (nconc
   '((&quot;date&quot; &quot;project&quot; &quot;hours&quot; &quot;task&quot;))
   '(hline)
   (let ((ast (org-element-parse-buffer 'element)))
     (org-element-map ast 'clock
       (lambda (x)
         (let* ((val (org-element-property :value x))
                (task (org-element-property :parent (org-element-property :parent x))))
           `(,(let ((year (org-element-property :year-start val))
                    (month (calendar-month-name
                            (org-element-property :month-start val)))
                    (day (org-element-property :day-start val)))
                ;; (insert (org-element-property :raw-value val))
                (format &quot;%s %s, %s&quot; month day year))
             ,(org-element-property :PROJECT task)
             ,(org-element-property :duration x)
             ,(org-element-property :title task)
             )))))
   '(hline)
   '((&quot;&quot; &quot;total:&quot; &quot;:=vsum(@2..@-1);T&quot; &quot;&quot;)))
#+END_SRC&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What this code block does is parse the buffer, and map the lambda function over all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;clock&lt;/code&gt; elements
in the buffer. For each element, we get its value (which is the datetime range), and its header, which contains
some properties, such as the project name. The name of the task is the header name.&lt;/p&gt;

&lt;p&gt;By prepending a list, we can also add headers. At the end, a &lt;code class=&quot;highlighter-rouge&quot;&gt;calc&lt;/code&gt; formula can be used for adding the times
to get a total. This formula sums the current column (hence the empty strings before and after), from the
second row (not including the header), up to the second to last row (not including the formula itself). The
&lt;code class=&quot;highlighter-rouge&quot;&gt;;T&lt;/code&gt; after the formula instructs it to add time, rather than numbers. Finally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;hline&lt;/code&gt; function inserts
a dashed line for making the table more presentable.&lt;/p&gt;

&lt;p&gt;Suppose the buffer looks like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot; data-lang=&quot;none&quot;&gt;#+BEGIN_SRC 
  * project 1

  ** Task 1
    :PROPERTIES:
    :PROJECT:  project_1
    :END:
    CLOCK: [2017-06-24 Sat 19:15]--[2017-06-24 Sat 22:05] =&amp;gt;  2:50


  ** Task 2
    :PROPERTIES:
    :PROJECT:  project_1
    :END:
    CLOCK: [2017-06-28 Wed 00:35]--[2017-06-28 Wed 03:35] =&amp;gt;  3:00
    CLOCK: [2017-06-27 Tue 16:55]--[2017-06-27 Tue 19:00] =&amp;gt;  2:05
    CLOCK: [2017-06-26 Mon 21:30]--[2017-06-27 Tue 01:00] =&amp;gt;  3:30

  * project 2

  ** Task 1
    :PROPERTIES:
    :PROJECT:  project_2
    :END:
    CLOCK: [2017-06-29 Thu 15:18]--[2017-06-29 Thu 18:18] =&amp;gt;  3:00
#+END_SRC&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the above code is wrapped in an &lt;code class=&quot;highlighter-rouge&quot;&gt;elisp&lt;/code&gt; block and executed (&lt;code class=&quot;highlighter-rouge&quot;&gt;C-c C-c&lt;/code&gt;), it outputs the
following table:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot; data-lang=&quot;none&quot;&gt;#+BEGIN_SRC 
  | date          | project   |             hours | task   |
  |---------------+-----------+-------------------+--------|
  | June 24, 2017 | project_1 |              2:50 | Task 1 |
  | June 28, 2017 | project_1 |              3:00 | Task 2 |
  | June 27, 2017 | project_1 |              2:05 | Task 2 |
  | June 26, 2017 | project_1 |              3:30 | Task 2 |
  | June 29, 2017 | project_2 |              3:00 | Task 1 |
  |---------------+-----------+-------------------+--------|
  |               | total:    | :=vsum(@2..@-1);T |        |
#+END_SRC&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To run the formula, press &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt; while in its cell.&lt;/p&gt;

&lt;p&gt;Afterwards, the table can be exported to csv with &lt;code class=&quot;highlighter-rouge&quot;&gt;org-table-export&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><category term="emacs" /><summary type="html">This post is originally adapted from this stackoverflow answer.</summary></entry></feed>